剑指offer题集
===

	|-- 第二章

		|-- 3. 二维数组的查找      Hint : 从右上开始查找    if a[1][m] == target  else if a[1]][m] < target  else if a[1][m] > target

		|-- 4. 字符串替换空格     遍历一遍找到空格个数m  申请数组n+2m(如何在尾部直接申请)   从尾部向头部遍历     字符串操作注意加'\0'

		|-- 5. 从尾到头打印链表    增加额外的栈，遍历链表存储到栈中，再遍历栈

		|-- 6. 重建二叉树         无论如何需要中序, 然后前序或后序    先通过前序或后序唯一确定根节点, 然后根据根节点在中序中的位置  唯一确定左右子树, 然后依次类推

		|-- 7. 用两个栈实现队列    队列的特点  队首进队尾出    push_front()   pop_back()    栈A,B  A栈管push_front()   B栈管pop_back()   判断数据位于栈A还是栈B, 以及当前的操作是push还是pop   如果位于栈A且是push则直接push到A栈中, 如果位于栈B且是pop则直接pop, 其他则需要将数据从当前栈移到另外的栈中，然后进行当前操作

#		|-- 8. 旋转数组的最小数字     二分查找    综合比较mid，left和right以及target的大小，判断下一次的left,right的值   if target=mid
		else if target > mid  left = mid+1;   else if target < mid right = mid;

#		|-- 9. Fibonnaci Sequence   递归 F(n) = F(n-1) + F(n-2)    循环  for(int i=2; i<=n;i++)  f[i] = f[i-1] + f[i-2];  矩阵   矩阵阶乘？

		|-- 10. 二进制中1的个数     ans = 0; while(n) { n = n&(n-1); ans ++; }    
				1. 判断a&(a-1) = 0  a 是二的幂次方
				2. a -> b 需要多少位   c = a^b 异或  求c中1的个数   

		|-- 11. 数值的整数次方     

		|-- 12. 打印从1到最大的n位数

		|-- 13. 在O(1)的时间删除链表节点     记录下一个节点的value值, 删除当前链表的下一个节点, 然后将当前链表的value替换为当前链表的value

		|-- 14. 调整数组顺序使奇数位于偶数前面     vmware面试题    只记得基础算法: 用额外的空间存储奇数数字和偶数数字, 然后将两者合并

		|-- 15. 链表中倒数第k个节点     先用一个指针从头遍历到第k节点位置, 然后再设一个指针指向头部, 然后两个指针一起遍历, 直到前面的指针碰到链表尾部(也就是遇到null)

		|-- 16. 反转链表   

		|-- 17. 合并两个排序的链表     两个指针分别指向链表, 看谁的小(升序), 则开始链接到新初始化的头部节点上

		|-- 18. 树的子结构

		|-- 19. 二叉树的镜像    如果当前节点不是叶子节点   则将其左右子树进行交换

#		|-- 20. 顺时针打印矩阵   n行m列   

		|-- 21. 包含min函数的栈     增加一个辅助栈  在主栈push的时候push当前栈中的最小值   在pop的时候pop栈首

		|-- 22. 栈的压入、弹出序列   

		|-- 23. 从上往下打印二叉树   广度优先遍历   每到一层, 将左右节点加入vector或者queue中

		|-- 24. 二叉搜索树的后序遍历序列   

		|-- 25. 二叉树中和为某一值的路径    

		|-- 26. 复杂链表的复制      

		|-- 27. 二叉搜索树与双向链表

		|-- 28. 字符串的排列

		|-- 29. 数组中出现次数超过一半的数字    设置一个num变量和val变量, 遇着第一个值赋值为1,val赋值为当前值, 然后遇到相同的+1, 遇到不同的-1

		|-- 30. 最小的k个数         设最小堆

		|-- 31. 连续子数组的最大和    从下标从n-1开始到0, 计算前缀和和最大和

		|-- 32. 从1到n整数中1出现的次数   需要分类讨论

#		|-- 33. 把数组排成最小的数

		|-- 34. 丑数   第n个丑数  只能被2,3和5整除的数   通过数组来存储最近的丑数 并通过新得到的丑数计算下一个丑数

		|-- 35. 第一个只出现一次的字符    用辅助存储空间   主要是字符的定义   ASCII码的字符 256个 UTF-8用四个字节进行编码 应该是2^31次方-1

#		|-- 36. 数组中的逆序对     归并算法   分解 - 合并  合并时计算逆序个数   O(nlogn)

		|-- 37. 两个链表的第一个公共节点     求两者的长度, m和n  然后abs(m-n) 对于多的先走两步, 然后一起走    *有时间可以练习下链表的基本操作*

		|-- *38. 数字在排序数组中出现的次数    数组已经有序   用二分查找可以找到最左和最右的值，然后相减即可   练习二分查找算法

		|-- 39. 二叉树的深度     从根到叶子节点的最长路径为树的深度    递归    当前节点的深度为左子节点的最大深度和右子节点的最大深度的最大值+1， 若没有左右子节点则深度为零

		|-- *40. 数组中只出现一次的数字     求异或
				如果是数组中有两个数字只出现一次，其他数字出现两次     将数组分拆  分拆标准 数组求异或后，选结果中某位为1的值，将数组分成两个子数组，再分别对两个子数组求异或, 即可求出两个只出现一次的数字

		|-- 41. 和为s的两个数字 VS 和为s的连续正数序列
				和为s的两个数字   有序数组 不有序则先排序 两个指针  一左一右, 如果和大于s, 右指针左移  小于s，左指针右移
				和为s的连续正数序列   毛毛虫算法   两个数字初始化为一  若小于s  则大数+1,  求大小数之间的数之和  大于s  则小数+1  再判断

		|-- 42. *反转单词顺序 VS 左旋字符串      先每个反转, 在整体反转    用字符串指针来进行
			反转单词顺序   先通过strlen求长度, 然后得到尾指针, 整体反转; 然后设两个指针，遍历字符串, 用毛毛虫法, 每次记录单词前后位置进行反转
			左旋字符串     字符串和旋转位置target   整体旋转, 字符串头到target  target+1到字符串尾部  分别旋转 

		|-- *43. n个骰子的点数    for(i=2;i<n;i++)  for(j=i;j<i*6;j++)   需要重置不能为的值,然后将值往上加

		|-- 44. 扑克牌的顺子      判断顺子的条件  连续的数字 或者可以通过大小王来填补空缺

		|-- 45. 圆圈中最后剩下的数字    通过映射关系  记住递推式吧  f(n,m) 为 0到n-1的n个数中, 每次取第m个数, 最后的数字   f(n,m) = (f(n-1,m) + m )%n

		|-- 46. 求1+2+...+n

		|-- *47. 不用加减乘除做加法       不能用四则运算   考虑二进制加法  并且区分是否进位    然后不算进位的加法可以转化为求异或, 进位可以转化为求与左移一位, 直到没有进位为止

		|-- 49. 把字符串转换成整数       非有效输入,空判断, 溢出情况 正负数  返回值适用于32位情况

		|-- 50. 树中两个节点的最低公共祖先	  深搜记录路径, 然后比较路径 找到最合适的点   路径的表示方式  链表 或者 字符数组
				* 二叉搜索树    判断当前节点root是否在两个节点中间, 如果是则是最低公共祖先, 否则必是都大或者都小的情况, 则分别向左右移动
				* 如果树中的节点有指向父节点的指针     转换成计算两个链表的第一个公共节点



